diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/core/nginx.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/nginx.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/core/nginx.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/nginx.c	2024-08-14 12:15:31.871993733 +0800
***************
*** 291,297 ****
      if (ngx_preinit_modules() != NGX_OK) {
          return 1;
      }
!     // wg-chain http-listen 1-2 : main中初始化cycle, in main call ngx_init_cycle
      cycle = ngx_init_cycle(&init_cycle);
      if (cycle == NULL) {
          if (ngx_test_config) {
--- 291,297 ----
      if (ngx_preinit_modules() != NGX_OK) {
          return 1;
      }
! 
      cycle = ngx_init_cycle(&init_cycle);
      if (cycle == NULL) {
          if (ngx_test_config) {
***************
*** 343,349 ****
      }
  
  #if !(NGX_WIN32)
!     // signal wg: 初始化信号处理逻辑
      if (ngx_init_signals(cycle->log) != NGX_OK) {
          return 1;
      }
--- 343,349 ----
      }
  
  #if !(NGX_WIN32)
! 
      if (ngx_init_signals(cycle->log) != NGX_OK) {
          return 1;
      }
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_conf_file.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_conf_file.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_conf_file.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_conf_file.c	2024-08-14 12:15:31.871993733 +0800
***************
*** 384,390 ****
  
              found = 1;
  
-             // wg: 这里的cf的module_type 是core 所以实际上所有的core module的命令在这之后就被执行了 
              if (cf->cycle->modules[i]->type != NGX_CONF_MODULE
                  && cf->cycle->modules[i]->type != cf->module_type)
              {
--- 384,389 ----
***************
*** 461,467 ****
                  }
              }
  
-             // wg: 执行所有core/config module的指令
              rv = cmd->set(cf, cmd, conf);
  
              if (rv == NGX_CONF_OK) {
--- 460,465 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_connection.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_connection.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_connection.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_connection.c	2024-08-14 12:15:31.871993733 +0800
***************
*** 24,30 ****
      ngx_listening_t  *ls;
      struct sockaddr  *sa;
      u_char            text[NGX_SOCKADDR_STRLEN];
!     // wg-chain http-listen 1-1-1: in ngx_create_listening 在cycle->listening 上创建了一个新的ls
      ls = ngx_array_push(&cf->cycle->listening);
      if (ls == NULL) {
          return NULL;
--- 24,30 ----
      ngx_listening_t  *ls;
      struct sockaddr  *sa;
      u_char            text[NGX_SOCKADDR_STRLEN];
! 
      ls = ngx_array_push(&cf->cycle->listening);
      if (ls == NULL) {
          return NULL;
***************
*** 486,492 ****
  
                  continue;
              }
!             // wg-chain http-listen 1: in ngx_open_listening_socketsc call ngx_socket 创建出socket
              s = ngx_socket(ls[i].sockaddr->sa_family, ls[i].type, 0);
  
              if (s == (ngx_socket_t) -1) {
--- 486,492 ----
  
                  continue;
              }
! 
              s = ngx_socket(ls[i].sockaddr->sa_family, ls[i].type, 0);
  
              if (s == (ngx_socket_t) -1) {
***************
*** 596,607 ****
              }
  
              ngx_log_debug2(NGX_LOG_DEBUG_CORE, log, 0,
!                            "bind() x %V #%d ", &ls[i].addr_text, s);
!             // wg: call bind
!             // wg: src/core/ngx_connection.c#L42 
!             ngx_wg_bind(log,s,&ls[i].addr_text,"wg: call bind");
  
-             // wg-chain http-listen 1+1: in ngx_open_listening_socketsc 调用bind
              if (bind(s, ls[i].sockaddr, ls[i].socklen) == -1) {
                  err = ngx_socket_errno;
  
--- 596,603 ----
              }
  
              ngx_log_debug2(NGX_LOG_DEBUG_CORE, log, 0,
!                            "bind() %V #%d ", &ls[i].addr_text, s);
  
              if (bind(s, ls[i].sockaddr, ls[i].socklen) == -1) {
                  err = ngx_socket_errno;
  
***************
*** 654,661 ****
                  ls[i].fd = s;
                  continue;
              }
!             // wg: 真正listening端口 这个s的read event就代表可以accept了
!             // wg-chain http-listen 1+2: in ngx_open_listening_socketsc 调用listen
              if (listen(s, ls[i].backlog) == -1) {
                  err = ngx_socket_errno;
  
--- 650,656 ----
                  ls[i].fd = s;
                  continue;
              }
! 
              if (listen(s, ls[i].backlog) == -1) {
                  err = ngx_socket_errno;
  
***************
*** 688,696 ****
                  continue;
              }
  
-             //listen wg: 设置listening的fd  为socket返回的fd
              ls[i].listen = 1;
!             // wg-chain http-listen 1+3: in ngx_open_listening_socketsc 设置ls[i].fd为我们的s socket
              ls[i].fd = s;
          }
  
--- 683,690 ----
                  continue;
              }
  
              ls[i].listen = 1;
! 
              ls[i].fd = s;
          }
  
***************
*** 1118,1124 ****
                        s, ngx_cycle->files_n);
          return NULL;
      }
!     // wg: gc reuseconnection
      ngx_drain_connections((ngx_cycle_t *) ngx_cycle);
  
      c = ngx_cycle->free_connections;
--- 1112,1118 ----
                        s, ngx_cycle->files_n);
          return NULL;
      }
! 
      ngx_drain_connections((ngx_cycle_t *) ngx_cycle);
  
      c = ngx_cycle->free_connections;
***************
*** 1130,1136 ****
  
          return NULL;
      }
!     // connection的data是next
      ngx_cycle->free_connections = c->data;
      ngx_cycle->free_connection_n--;
  
--- 1124,1130 ----
  
          return NULL;
      }
! 
      ngx_cycle->free_connections = c->data;
      ngx_cycle->free_connection_n--;
  
***************
*** 1140,1151 ****
  
      rev = c->read;
      wev = c->write;
!     // wg: 清空了这个connection
      ngx_memzero(c, sizeof(ngx_connection_t));
  
      c->read = rev;
      c->write = wev;
-     // wg: 这里的connection的fd,就是socket的fd
      c->fd = s;
      c->log = log;
  
--- 1134,1144 ----
  
      rev = c->read;
      wev = c->write;
! 
      ngx_memzero(c, sizeof(ngx_connection_t));
  
      c->read = rev;
      c->write = wev;
      c->fd = s;
      c->log = log;
  
***************
*** 1159,1166 ****
  
      rev->index = NGX_INVALID_INDEX;
      wev->index = NGX_INVALID_INDEX;
!     // event wg: event 的data 是connection
!     // wg-chain http-listen 2-1-3+1: c->read->data=c 设置connection的read的data指针为自己  in ngx_get_connection
      rev->data = c;
      wev->data = c;
  
--- 1152,1158 ----
  
      rev->index = NGX_INVALID_INDEX;
      wev->index = NGX_INVALID_INDEX;
! 
      rev->data = c;
      wev->data = c;
  
***************
*** 1337,1343 ****
  
          ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,
                         "reusing connection");
!         // wg: 这实际上就是关掉这个connection
          c->close = 1;
          c->read->handler(c->read);
      }
--- 1329,1335 ----
  
          ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,
                         "reusing connection");
! 
          c->close = 1;
          c->read->handler(c->read);
      }
***************
*** 1551,1559 ****
  
      return NGX_ERROR;
  }
- 
- void
- ngx_wg_bind(ngx_log_t *log,int fd,ngx_str_t* addr,char * msg) {
-    // this function used to track nginx listen event.
-     int j;*(volatile int *)&j = 1; // 这行保证不会被优化掉
- }
\ No newline at end of file
--- 1543,1545 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_connection.h ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_connection.h
*** ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_connection.h	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_connection.h	2024-08-14 12:15:31.871993733 +0800
***************
*** 35,42 ****
  #endif
  
      /* handler of accepted connection */
-     //wg: 连接建立后的回调函数
-     // http wg:  src/http/ngx_http.c#L1714
      ngx_connection_handler_pt   handler;
  
      void               *servers;  /* array of ngx_http_in_addr_t, for example */
--- 35,40 ----
***************
*** 226,231 ****
  
  void ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable);
  
- // void ngx_wg_listen();
- void ngx_wg_bind(ngx_log_t * log,int fd,ngx_str_t *addr ,char * msg);
  #endif /* _NGX_CONNECTION_H_INCLUDED_ */
--- 224,227 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_cycle.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_cycle.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_cycle.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_cycle.c	2024-08-14 12:15:31.871993733 +0800
***************
*** 221,233 ****
  
      ngx_strlow(cycle->hostname.data, (u_char *) hostname, cycle->hostname.len);
  
!     // wg: nginx的module是编译脚本直接生成的,根据配置来的,是静态的,这里把这些module拷贝到了这个cycle中
      if (ngx_cycle_modules(cycle) != NGX_OK) {
          ngx_destroy_pool(pool);
          return NULL;
      }
  
!     // wg: call core module's create_conf
      for (i = 0; cycle->modules[i]; i++) {
          if (cycle->modules[i]->type != NGX_CORE_MODULE) {
              continue;
--- 221,233 ----
  
      ngx_strlow(cycle->hostname.data, (u_char *) hostname, cycle->hostname.len);
  
! 
      if (ngx_cycle_modules(cycle) != NGX_OK) {
          ngx_destroy_pool(pool);
          return NULL;
      }
  
! 
      for (i = 0; cycle->modules[i]; i++) {
          if (cycle->modules[i]->type != NGX_CORE_MODULE) {
              continue;
***************
*** 280,286 ****
          ngx_destroy_cycle_pools(&conf);
          return NULL;
      }
!     // wg: 解析nginx.conf 
      if (ngx_conf_parse(&conf, &cycle->conf_file) != NGX_CONF_OK) {
          environ = senv;
          ngx_destroy_cycle_pools(&conf);
--- 280,286 ----
          ngx_destroy_cycle_pools(&conf);
          return NULL;
      }
! 
      if (ngx_conf_parse(&conf, &cycle->conf_file) != NGX_CONF_OK) {
          environ = senv;
          ngx_destroy_cycle_pools(&conf);
***************
*** 291,297 ****
          ngx_log_stderr(0, "the configuration file %s syntax is ok",
                         cycle->conf_file.data);
      }
!     // wg: 调用所有core module 的init conf
      for (i = 0; cycle->modules[i]; i++) {
          if (cycle->modules[i]->type != NGX_CORE_MODULE) {
              continue;
--- 291,297 ----
          ngx_log_stderr(0, "the configuration file %s syntax is ok",
                         cycle->conf_file.data);
      }
! 
      for (i = 0; cycle->modules[i]; i++) {
          if (cycle->modules[i]->type != NGX_CORE_MODULE) {
              continue;
***************
*** 614,620 ****
  #endif
          }
      }
!     // wg-chain http-listen 1-1: in ngx_init_cycle call ngx_open_listening_sockets 开始监听端口
      if (ngx_open_listening_sockets(cycle) != NGX_OK) {
          goto failed;
      }
--- 614,620 ----
  #endif
          }
      }
! 
      if (ngx_open_listening_sockets(cycle) != NGX_OK) {
          goto failed;
      }
***************
*** 1441,1447 ****
  }
  
  
- // reload wg: 到了规定的时间但还是没退出成功 手动把连接read 关掉
  static void
  ngx_shutdown_timer_handler(ngx_event_t *ev)
  {
--- 1441,1446 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_times.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_times.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/core/ngx_times.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/core/ngx_times.c	2024-08-14 12:15:31.871993733 +0800
***************
*** 47,53 ****
  
  static ngx_time_t        cached_time[NGX_TIME_SLOTS];
  static u_char            cached_err_log_time[NGX_TIME_SLOTS]
!                                     [sizeof("1970/09/28 12:00:00 0000")];
  static u_char            cached_http_time[NGX_TIME_SLOTS]
                                      [sizeof("Mon, 28 Sep 1970 06:00:00 GMT")];
  static u_char            cached_http_log_time[NGX_TIME_SLOTS]
--- 47,53 ----
  
  static ngx_time_t        cached_time[NGX_TIME_SLOTS];
  static u_char            cached_err_log_time[NGX_TIME_SLOTS]
!                                     [sizeof("1970/09/28 12:00:00")];
  static u_char            cached_http_time[NGX_TIME_SLOTS]
                                      [sizeof("Mon, 28 Sep 1970 06:00:00 GMT")];
  static u_char            cached_http_log_time[NGX_TIME_SLOTS]
***************
*** 65,71 ****
  void
  ngx_time_init(void)
  {
!     ngx_cached_err_log_time.len = sizeof("1970/09/28 12:00:00 000") - 1;
      ngx_cached_http_time.len = sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1;
      ngx_cached_http_log_time.len = sizeof("28/Sep/1970:12:00:00 +0600") - 1;
      ngx_cached_http_log_iso8601.len = sizeof("1970-09-28T12:00:00+06:00") - 1;
--- 65,71 ----
  void
  ngx_time_init(void)
  {
!     ngx_cached_err_log_time.len = sizeof("1970/09/28 12:00:00") - 1;
      ngx_cached_http_time.len = sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1;
      ngx_cached_http_log_time.len = sizeof("28/Sep/1970:12:00:00 +0600") - 1;
      ngx_cached_http_log_iso8601.len = sizeof("1970-09-28T12:00:00+06:00") - 1;
***************
*** 100,110 ****
  
      tp = &cached_time[slot];
  
!     // if (tp->sec == sec) {
!     //     tp->msec = msec;
!     //     ngx_unlock(&ngx_time_lock);
!     //     return;
!     // }
  
      if (slot == NGX_TIME_SLOTS - 1) {
          slot = 0;
--- 100,110 ----
  
      tp = &cached_time[slot];
  
!     if (tp->sec == sec) {
!         tp->msec = msec;
!         ngx_unlock(&ngx_time_lock);
!         return;
!     }
  
      if (slot == NGX_TIME_SLOTS - 1) {
          slot = 0;
***************
*** 149,158 ****
  
      p1 = &cached_err_log_time[slot][0];
  
!     (void) ngx_sprintf(p1, "%4d/%02d/%02d %02d:%02d:%02d %03d",
                         tm.ngx_tm_year, tm.ngx_tm_mon,
                         tm.ngx_tm_mday, tm.ngx_tm_hour,
!                        tm.ngx_tm_min, tm.ngx_tm_sec,msec);
  
  
      p2 = &cached_http_log_time[slot][0];
--- 149,158 ----
  
      p1 = &cached_err_log_time[slot][0];
  
!     (void) ngx_sprintf(p1, "%4d/%02d/%02d %02d:%02d:%02d",
                         tm.ngx_tm_year, tm.ngx_tm_mon,
                         tm.ngx_tm_mday, tm.ngx_tm_hour,
!                        tm.ngx_tm_min, tm.ngx_tm_sec);
  
  
      p2 = &cached_http_log_time[slot][0];
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/event/modules/ngx_epoll_module.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/modules/ngx_epoll_module.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/event/modules/ngx_epoll_module.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/modules/ngx_epoll_module.c	2024-08-14 12:15:31.875331027 +0800
***************
*** 623,629 ****
      ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                     "epoll add event: fd:%d op:%d ev:%08XD",
                     c->fd, op, ee.events);
!     // wg: 将event加入到epool中去,注意这里的fd是 event.data->fd,在accept时就是connection上的fd,就是socket的那个fd
      if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
          ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
                        "epoll_ctl(%d, %d) failed", op, c->fd);
--- 623,629 ----
      ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                     "epoll add event: fd:%d op:%d ev:%08XD",
                     c->fd, op, ee.events);
! 
      if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
          ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
                        "epoll_ctl(%d, %d) failed", op, c->fd);
***************
*** 703,714 ****
      struct epoll_event  ee;
  
      ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;
-     // wg: ngx_epoll_module.c#L841
      ee.data.ptr = (void *) ((uintptr_t) c | c->read->instance);
  
      ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                     "epoll add connection: fd:%d ev:%08XD", c->fd, ee.events);
!     // event wg: 提交连接到epool
      if (epoll_ctl(ep, EPOLL_CTL_ADD, c->fd, &ee) == -1) {
          ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                        "epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->fd);
--- 703,713 ----
      struct epoll_event  ee;
  
      ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;
      ee.data.ptr = (void *) ((uintptr_t) c | c->read->instance);
  
      ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                     "epoll add connection: fd:%d ev:%08XD", c->fd, ee.events);
! 
      if (epoll_ctl(ep, EPOLL_CTL_ADD, c->fd, &ee) == -1) {
          ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
                        "epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->fd);
***************
*** 780,786 ****
  
  #endif
  
! // wg: 实际上就是 bundle/nginx-1.19.9/src/event/ngx_event.c:258
  static ngx_int_t
  ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
  {
--- 779,785 ----
  
  #endif
  
! 
  static ngx_int_t
  ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
  {
***************
*** 797,803 ****
  
      ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                     "epoll timer: %M", timer);
!     // wg: epoll wait 将活跃的event 放到 event_list中,event_list 是全局的.
      events = epoll_wait(ep, event_list, (int) nevents, timer);
  
      err = (events == -1) ? ngx_errno : 0;
--- 796,802 ----
  
      ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                     "epoll timer: %M", timer);
! 
      events = epoll_wait(ep, event_list, (int) nevents, timer);
  
      err = (events == -1) ? ngx_errno : 0;
***************
*** 839,845 ****
  
          instance = (uintptr_t) c & 1;
          c = (ngx_connection_t *) ((uintptr_t) c & (uintptr_t) ~1);
!         // event wg: 拿connection的read事件, 上面的fd是listen的fd 在 ngx_get_connection中设置的
          rev = c->read;
  
          if (c->fd == -1 || rev->instance != instance) {
--- 838,844 ----
  
          instance = (uintptr_t) c & 1;
          c = (ngx_connection_t *) ((uintptr_t) c & (uintptr_t) ~1);
! 
          rev = c->read;
  
          if (c->fd == -1 || rev->instance != instance) {
***************
*** 853,863 ****
                             "epoll: stale event %p", c);
              continue;
          }
!         // wg: epoll_event 中的events是个bitmask,可以用来区分read还是write , EPOLLIN 是0x1 EPOLLOUT 是0x10(4)
          revents = event_list[i].events;
  
          ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
!                        "epoll: procoess_event fd:%d ev:%04XD d:%p",
                         c->fd, revents, event_list[i].data.ptr);
  
          if (revents & (EPOLLERR|EPOLLHUP)) {
--- 852,862 ----
                             "epoll: stale event %p", c);
              continue;
          }
! 
          revents = event_list[i].events;
  
          ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
!                        "epoll: fd:%d ev:%04XD d:%p",
                         c->fd, revents, event_list[i].data.ptr);
  
          if (revents & (EPOLLERR|EPOLLHUP)) {
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/event/ngx_event_accept.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/ngx_event_accept.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/event/ngx_event_accept.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/ngx_event_accept.c	2024-08-14 12:15:31.875331027 +0800
***************
*** 44,51 ****
      if (!(ngx_event_flags & NGX_USE_KQUEUE_EVENT)) {
          ev->available = ecf->multi_accept;
      }
!     // wg: 这个lc代表的是listen时get到的connection
!     // wg: bundle/nginx-1.19.9/src/core/ngx_connection.c:1160 ngx_get_connection 时设置进去的 
      lc = ev->data;
      ls = lc->listening;
      ev->ready = 0;
--- 44,50 ----
      if (!(ngx_event_flags & NGX_USE_KQUEUE_EVENT)) {
          ev->available = ecf->multi_accept;
      }
! 
      lc = ev->data;
      ls = lc->listening;
      ev->ready = 0;
***************
*** 58,65 ****
  
  #if (NGX_HAVE_ACCEPT4)
          if (use_accept4) {
-             //net wg: 设置accept的socket是非阻塞的
-             // wg-chain http-listen 2: in ngx_event_accept 调用accept 拿到一个代表新连接的s
              s = accept4(lc->fd, &sa.sockaddr, &socklen,
                          SOCK_NONBLOCK | SOCK_CLOEXEC);
  
--- 57,62 ----
***************
*** 140,149 ****
  
          ngx_accept_disabled = ngx_cycle->connection_n / 8
                                - ngx_cycle->free_connection_n;
-         //connection wg: 在成功accept之后会在调用一次get_connection
-         // TODO add trace here
  
-         // wg-chain http-listen 2+1: in ngx_event_accept 用s调用ngx_get_connection 拿到nginx中一个代表这个新连接的ngx_conn对象
          c = ngx_get_connection(s, ev->log);
  
          if (c == NULL) {
--- 137,143 ----
***************
*** 271,277 ****
           *           - ngx_atomic_fetch_add()
           *             or protection by critical section or light mutex
           */
!         // TODO 这里的number代表什么?
          c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);
  
  #if (NGX_STAT_STUB)
--- 265,271 ----
           *           - ngx_atomic_fetch_add()
           *             or protection by critical section or light mutex
           */
! 
          c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);
  
  #if (NGX_STAT_STUB)
***************
*** 314,321 ****
  #endif
  
          if (ngx_add_conn && (ngx_event_flags & NGX_USE_EPOLL_EVENT) == 0) {
-             // event wg: 这里的connection已经是accept的fd了 当socket可读的时候会调用 c->read.handler,这个handle是在ls->handler(c)的调用中设置的,对http来说就是ngx_http_init_connection中设置的 就是 ngx_http_wait_request_handler   ngx_http_request.c#326
-             // wg-chain http-listen 2+2: in ngx_event_accept 用c调用ngx_add_conn
              if (ngx_add_conn(c) == NGX_ERROR) {
                  ngx_close_accepted_connection(c);
                  return;
--- 308,313 ----
***************
*** 324,332 ****
  
          log->data = NULL;
          log->handler = NULL;
!         // wg: http wg:  src/http/ngx_http.c#L1714 ngx_http_request.c#l207 ngx_http_init_connection
!         // wg: ls上的handler是在ngx_http_add_listening中设置的
!         // wg-chain http-listen 2+3: in ngx_event_accept 调用ls->handler(c).ls 是ev->data->listening
          ls->handler(c);
  
          if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
--- 316,322 ----
  
          log->data = NULL;
          log->handler = NULL;
! 
          ls->handler(c);
  
          if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
***************
*** 348,354 ****
          if (ngx_accept_mutex_held && ngx_accept_events == 0) {
              return NGX_OK;
          }
!         //wg: 拿到锁的人会真正那把这个端口的连接事件加到epoll中
          if (ngx_enable_accept_events(cycle) == NGX_ERROR) {
              ngx_shmtx_unlock(&ngx_accept_mutex);
              return NGX_ERROR;
--- 338,344 ----
          if (ngx_accept_mutex_held && ngx_accept_events == 0) {
              return NGX_OK;
          }
! 
          if (ngx_enable_accept_events(cycle) == NGX_ERROR) {
              ngx_shmtx_unlock(&ngx_accept_mutex);
              return NGX_ERROR;
***************
*** 390,396 ****
          if (c == NULL || c->read->active) {
              continue;
          }
!         // wg: ngx_event.c#920
          if (ngx_add_event(c->read, NGX_READ_EVENT, 0) == NGX_ERROR) {
              return NGX_ERROR;
          }
--- 380,386 ----
          if (c == NULL || c->read->active) {
              continue;
          }
! 
          if (ngx_add_event(c->read, NGX_READ_EVENT, 0) == NGX_ERROR) {
              return NGX_ERROR;
          }
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/event/ngx_event.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/ngx_event.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/event/ngx_event.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/ngx_event.c	2024-08-14 12:15:31.875331027 +0800
***************
*** 230,236 ****
              ngx_accept_disabled--;
  
          } else {
-             // wg: 争夺一个锁 拿到锁的人会去真正accept,在他hold住锁的期间，其他的worker不能做任何事情
              if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) {
                  return;
              }
--- 230,235 ----
***************
*** 252,267 ****
          ngx_event_move_posted_next(cycle);
          timer = 0;
      }
!     // wg: patch 每次都去更新时间
!     ngx_time_update();
      delta = ngx_current_msec;
!     //wg: 这实际上就是ngx_epoll_process_events
      (void) ngx_process_events(cycle, timer, flags);
  
      delta = ngx_current_msec - delta;
!     // wg: patch add more log.
!     ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
!                    "timer delta: %M %M",ngx_current_msec, delta);
  
      ngx_event_process_posted(cycle, &ngx_posted_accept_events);
  
--- 251,265 ----
          ngx_event_move_posted_next(cycle);
          timer = 0;
      }
! 
      delta = ngx_current_msec;
! 
      (void) ngx_process_events(cycle, timer, flags);
  
      delta = ngx_current_msec - delta;
! 
!     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
!                    "timer delta: %M", delta);
  
      ngx_event_process_posted(cycle, &ngx_posted_accept_events);
  
***************
*** 765,771 ****
      }
  
  #endif
!     // wg: 分配所有的连接
      cycle->connections =
          ngx_alloc(sizeof(ngx_connection_t) * cycle->connection_n, cycle->log);
      if (cycle->connections == NULL) {
--- 763,769 ----
      }
  
  #endif
! 
      cycle->connections =
          ngx_alloc(sizeof(ngx_connection_t) * cycle->connection_n, cycle->log);
      if (cycle->connections == NULL) {
***************
*** 799,805 ****
  
      i = cycle->connection_n;
      next = NULL;
!     // wg: 初始化connection 链表
      do {
          i--;
  
--- 797,803 ----
  
      i = cycle->connection_n;
      next = NULL;
! 
      do {
          i--;
  
***************
*** 817,823 ****
      /* for each listening socket */
  
      ls = cycle->listening.elts;
-     //wg: 上面初始化好了链接之后,就被每个listenng的端口分配一个connection
      for (i = 0; i < cycle->listening.nelts; i++) {
  
  #if (NGX_HAVE_REUSEPORT)
--- 815,820 ----
***************
*** 837,846 ****
              continue;
          }
  #endif
-         // wg: 给每一个端口分配一个连接 这里的ls[i].fd ,就是监听的端口的socket fd  是在  ngx_init_cycle 的 ngx_open_listening_sockets 最终也就是 ngx_connection.c#L689 中设置的
-         // wg: 这里会更新connection的fd
  
-         // wg-chain http-listen 2-1-3: c = ngx_get_connection(ls[i].fd  in ngx_event_process_init
          c = ngx_get_connection(ls[i].fd, cycle->log);
  
          if (c == NULL) {
--- 834,840 ----
***************
*** 850,861 ****
          c->type = ls[i].type;
          c->log = &ls[i].log;
  
-         // wg-chain http-listen 2-1-2: c->listening = &ls[i]; in ngx_event_process_init
          c->listening = &ls[i];
-         // wg: 将listening上的connection设置为从连接池中分配好的一个connection
          ls[i].connection = c;
  
-         // wg: 后面要加到eventpool中的rev是connection上的read事件, read事件的fd就是listen的fd
          rev = c->read;
  
          rev->log = c->log;
--- 844,852 ----
***************
*** 923,930 ****
  
  #else
  
-         // wg: 将连接的read事件handle设置为 ngx_event_accept 即说明可以accept了 对于udp来言就是可以recvmsg了
-         // wg-chain http-listen 2-1-1: 将连接的read事件handle设置为 ngx_event_accept  in ngx_event_process_init 
          rev->handler = (c->type == SOCK_STREAM) ? ngx_event_accept
                                                  : ngx_event_recvmsg;
  
--- 914,919 ----
***************
*** 959,965 ****
          }
  
  #endif
!         // wg-chain http-listen 2-1: in ngx_event_process_init 将事件加入到epol中去,这个事件代表可以accept,handle是ngx_accept_evne
          if (ngx_add_event(rev, NGX_READ_EVENT, 0) == NGX_ERROR) {
              return NGX_ERROR;
          }
--- 948,954 ----
          }
  
  #endif
! 
          if (ngx_add_event(rev, NGX_READ_EVENT, 0) == NGX_ERROR) {
              return NGX_ERROR;
          }
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/event/ngx_event_connect.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/ngx_event_connect.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/event/ngx_event_connect.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/event/ngx_event_connect.c	2024-08-14 12:15:31.875331027 +0800
***************
*** 217,223 ****
  
      ngx_log_debug3(NGX_LOG_DEBUG_EVENT, pc->log, 0,
                     "connect to %V, fd:%d #%uA", pc->name, s, c->number);
!     //wg: 难道每次连到后端都会重新connect?
      rc = connect(s, pc->sockaddr, pc->socklen);
  
      if (rc == -1) {
--- 217,223 ----
  
      ngx_log_debug3(NGX_LOG_DEBUG_EVENT, pc->log, 0,
                     "connect to %V, fd:%d #%uA", pc->name, s, c->number);
! 
      rc = connect(s, pc->sockaddr, pc->socklen);
  
      if (rc == -1) {
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/http/modules/ngx_http_log_module.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/modules/ngx_http_log_module.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/http/modules/ngx_http_log_module.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/modules/ngx_http_log_module.c	2024-08-14 12:15:31.878668321 +0800
***************
*** 235,241 ****
  
  
  static ngx_str_t  ngx_http_combined_fmt =
!     ngx_string("wg-log-test: $remote_addr - $remote_user [$time_local] "
                 "\"$request\" $status $body_bytes_sent "
                 "\"$http_referer\" \"$http_user_agent\"");
  
--- 235,241 ----
  
  
  static ngx_str_t  ngx_http_combined_fmt =
!     ngx_string("$remote_addr - $remote_user [$time_local] "
                 "\"$request\" $status $body_bytes_sent "
                 "\"$http_referer\" \"$http_user_agent\"");
  
***************
*** 1925,1937 ****
  
      h = ngx_array_push(&cmcf->phases[NGX_HTTP_LOG_PHASE].handlers);
      if (h == NULL) {
-         return NGX_ERROR;
-     }
- 
-     *h = ngx_http_log_handler;
- 
-     h = ngx_array_push(&cmcf->phases[NGX_HTTP_LOG_PHASE].handlers);
-     if (h == NULL) {
          return NGX_ERROR;
      }
  
--- 1925,1930 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http.c	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http.c	2024-08-14 12:15:31.875331027 +0800
***************
*** 330,336 ****
  
  
      /* optimize the lists of ports, addresses and server names */
!     // wg-chain http-listen 1-1-5: in ngx_http_block nginx.conf 中 http block的解析逻辑 call ngx_http_optimize_servers
      if (ngx_http_optimize_servers(cf, cmcf, cmcf->ports) != NGX_OK) {
          return NGX_CONF_ERROR;
      }
--- 329,335 ----
  
  
      /* optimize the lists of ports, addresses and server names */
! 
      if (ngx_http_optimize_servers(cf, cmcf, cmcf->ports) != NGX_OK) {
          return NGX_CONF_ERROR;
      }
***************
*** 451,463 ****
  static ngx_int_t
  ngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)
  {
-     // http-phase wg: 初始化phase handle
-     // wg: ngx_http_core_run_phases
      ngx_int_t                   j;
      ngx_uint_t                  i, n;
      ngx_uint_t                  find_config_index, use_rewrite, use_access;
!     ngx_http_handler_pt         *h;
!     ngx_uint_t                  hnn;
      ngx_http_phase_handler_t   *ph;
      ngx_http_phase_handler_pt   checker;
  
--- 451,460 ----
  static ngx_int_t
  ngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)
  {
      ngx_int_t                   j;
      ngx_uint_t                  i, n;
      ngx_uint_t                  find_config_index, use_rewrite, use_access;
!     ngx_http_handler_pt        *h;
      ngx_http_phase_handler_t   *ph;
      ngx_http_phase_handler_pt   checker;
  
***************
*** 471,478 ****
          + use_rewrite      /* post rewrite phase */
          + use_access;      /* post access phase */
  
-     ngx_log_debug3(NGX_LOG_DEBUG_HTTP, cf->log, 0,
-                    "wg: ngx_http_init_phase_handlers n %d rewrite %d access %d",n,use_rewrite,use_access);
      for (i = 0; i < NGX_HTTP_LOG_PHASE; i++) {
          n += cmcf->phases[i].handlers.nelts;
      }
--- 468,473 ----
***************
*** 488,494 ****
  
      for (i = 0; i < NGX_HTTP_LOG_PHASE; i++) {
          h = cmcf->phases[i].handlers.elts;
-         hnn = cmcf->phase_names[i].names.nelts;
  
          switch (i) {
  
--- 483,488 ----
***************
*** 550,561 ****
          }
  
          n += cmcf->phases[i].handlers.nelts;
!         // wg: 倒序 从后往前
          for (j = cmcf->phases[i].handlers.nelts - 1; j >= 0; j--) {
              ph->checker = checker;
              ph->handler = h[j];
!             
!             ph->next = n; //wg: next指向下一阶段
              ph++;
          }
      }
--- 544,554 ----
          }
  
          n += cmcf->phases[i].handlers.nelts;
! 
          for (j = cmcf->phases[i].handlers.nelts - 1; j >= 0; j--) {
              ph->checker = checker;
              ph->handler = h[j];
!             ph->next = n;
              ph++;
          }
      }
***************
*** 1419,1425 ****
              }
          }
  
-         // wg-chain http-listen 1-1-4: in ngx_http_optimize_servers call ngx_http_init_listening  
          if (ngx_http_init_listening(cf, &port[p]) != NGX_OK) {
              return NGX_ERROR;
          }
--- 1412,1417 ----
***************
*** 1665,1671 ****
              i++;
              continue;
          }
!         // wg-chain http-listen 1-1-3: in ngx_http_init_listening call  ngx_http_add_listening
          ls = ngx_http_add_listening(cf, &addr[i]);
          if (ls == NULL) {
              return NGX_ERROR;
--- 1657,1663 ----
              i++;
              continue;
          }
! 
          ls = ngx_http_add_listening(cf, &addr[i]);
          if (ls == NULL) {
              return NGX_ERROR;
***************
*** 1710,1726 ****
      ngx_listening_t           *ls;
      ngx_http_core_loc_conf_t  *clcf;
      ngx_http_core_srv_conf_t  *cscf;
-     // wg: listening 4
  
-     // wg-chain http-listen 1-1-2: in ngx_http_add_listening call ngx_create_listening
      ls = ngx_create_listening(cf, addr->opt.sockaddr, addr->opt.socklen);
      if (ls == NULL) {
          return NULL;
      }
  
      ls->addr_ntop = 1;
!     // wg: listening 
!     // wg-chain http-listen 1-1-2+1: 设置ls的handler 为 ngx_http_init_connection  in ngx_http_add_listening 
      ls->handler = ngx_http_init_connection;
  
      cscf = addr->default_server;
--- 1702,1715 ----
      ngx_listening_t           *ls;
      ngx_http_core_loc_conf_t  *clcf;
      ngx_http_core_srv_conf_t  *cscf;
  
      ls = ngx_create_listening(cf, addr->opt.sockaddr, addr->opt.socklen);
      if (ls == NULL) {
          return NULL;
      }
  
      ls->addr_ntop = 1;
! 
      ls->handler = ngx_http_init_connection;
  
      cscf = addr->default_server;
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http_core_module.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http_core_module.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http_core_module.c	2024-08-14 12:16:22.223480211 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http_core_module.c	2024-08-14 12:15:31.875331027 +0800
***************
*** 863,883 ****
  
  
  void
- ngx_http_core_run_phases_check_eyes(ngx_http_phase_handler_pt checker, ngx_http_handler_pt handler, ngx_int_t handle_index,ngx_int_t rc )
- { 
-     int j;*(volatile int *)&j = 1; // 这行保证不会被优化掉
- }
- 
- void
- ngx_http_set_location_handle_eyes(ngx_http_handler_pt handler)
- { 
-     int j;*(volatile int *)&j = 1; // 这行保证不会被优化掉
- }
- 
- void
  ngx_http_core_run_phases(ngx_http_request_t *r)
  {
-     // wg: nginx http 的7个阶段的入口
      ngx_int_t                   rc;
      ngx_http_phase_handler_t   *ph;
      ngx_http_core_main_conf_t  *cmcf;
--- 863,870 ----
***************
*** 887,894 ****
      ph = cmcf->phase_engine.handlers;
  
      while (ph[r->phase_handler].checker) {
          rc = ph[r->phase_handler].checker(r, &ph[r->phase_handler]);
-         ngx_http_core_run_phases_check_eyes(ph[r->phase_handler].checker,ph[r->phase_handler].handler, r->phase_handler,rc);
  
          if (rc == NGX_OK) {
              return;
--- 874,881 ----
      ph = cmcf->phase_engine.handlers;
  
      while (ph[r->phase_handler].checker) {
+ 
          rc = ph[r->phase_handler].checker(r, &ph[r->phase_handler]);
  
          if (rc == NGX_OK) {
              return;
***************
*** 991,997 ****
                     "using configuration \"%s%V\"",
                     (clcf->noname ? "*" : (clcf->exact_match ? "=" : "")),
                     &clcf->name);
!     // wg: 这个函数中设置了 request上的content_handle
      ngx_http_update_location_config(r);
  
      ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
--- 978,984 ----
                     "using configuration \"%s%V\"",
                     (clcf->noname ? "*" : (clcf->exact_match ? "=" : "")),
                     &clcf->name);
! 
      ngx_http_update_location_config(r);
  
      ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
***************
*** 1269,1275 ****
      size_t     root;
      ngx_int_t  rc;
      ngx_str_t  path;
!     // wg: 如何find config 阶段设置了 content_handle 在core_content_phase中实际上不会管 phase_handle
      if (r->content_handler) {
          r->write_event_handler = ngx_http_request_empty_handler;
          ngx_http_finalize_request(r, r->content_handler(r));
--- 1256,1262 ----
      size_t     root;
      ngx_int_t  rc;
      ngx_str_t  path;
! 
      if (r->content_handler) {
          r->write_event_handler = ngx_http_request_empty_handler;
          ngx_http_finalize_request(r, r->content_handler(r));
***************
*** 1389,1395 ****
  
      if (clcf->handler) {
          r->content_handler = clcf->handler;
-         ngx_http_set_location_handle_eyes(r->content_handler);
      }
  }
  
--- 1376,1381 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http_core_module.h ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http_core_module.h
*** ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http_core_module.h	2024-08-14 12:16:22.223480211 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http_core_module.h	2024-08-14 12:15:31.875331027 +0800
***************
*** 138,144 ****
  
  
  typedef struct {
-     // wg: 真正的handle在这里
      ngx_http_phase_handler_t  *handlers;
      ngx_uint_t                 server_rewrite_index;
      ngx_uint_t                 location_rewrite_index;
--- 138,143 ----
***************
*** 149,161 ****
      ngx_array_t                handlers;
  } ngx_http_phase_t;
  
- typedef struct {
-     ngx_array_t names;
- } ngx_http_phase_name_t;
  
  typedef struct {
      ngx_array_t                servers;         /* ngx_http_core_srv_conf_t */
!     // 真正的handle存储在这里
      ngx_http_phase_engine_t    phase_engine;
  
      ngx_hash_t                 headers_in_hash;
--- 148,157 ----
      ngx_array_t                handlers;
  } ngx_http_phase_t;
  
  
  typedef struct {
      ngx_array_t                servers;         /* ngx_http_core_srv_conf_t */
! 
      ngx_http_phase_engine_t    phase_engine;
  
      ngx_hash_t                 headers_in_hash;
***************
*** 175,183 ****
      ngx_hash_keys_arrays_t    *variables_keys;
  
      ngx_array_t               *ports;
!     //wg: 更类似一个临时变量 各module在post config中将自己的handle注册到这里 在ngx_http_init_phase_handlers中用这里存的handle 放到  phase_engine 中
!     ngx_http_phase_t           phases[NGX_HTTP_LOG_PHASE + 1]; 
!     ngx_http_phase_name_t      phase_names[NGX_HTTP_LOG_PHASE + 1]; 
  } ngx_http_core_main_conf_t;
  
  
--- 171,178 ----
      ngx_hash_keys_arrays_t    *variables_keys;
  
      ngx_array_t               *ports;
! 
!     ngx_http_phase_t           phases[NGX_HTTP_LOG_PHASE + 1];
  } ngx_http_core_main_conf_t;
  
  
***************
*** 472,479 ****
  };
  
  
- void __attribute__((noinline)) ngx_http_core_run_phases_check_eyes(ngx_http_phase_handler_pt checker,ngx_http_handler_pt handler,ngx_int_t index,ngx_int_t rc);
- void __attribute__((noinline)) ngx_http_set_location_handle_eyes(ngx_http_handler_pt handler);
  void ngx_http_core_run_phases(ngx_http_request_t *r);
  ngx_int_t ngx_http_core_generic_phase(ngx_http_request_t *r,
      ngx_http_phase_handler_t *ph);
--- 467,472 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http.h ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http.h
*** ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http.h	2024-08-14 12:16:22.220145242 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http.h	2024-08-14 12:15:31.875331027 +0800
***************
*** 162,171 ****
  ngx_int_t ngx_http_set_default_types(ngx_conf_t *cf, ngx_array_t **types,
      ngx_str_t *default_type);
  
- 
- void __attribute__((noinline)) ngx_http_eyes_test_args(int arg);
- 
- 
  #if (NGX_HTTP_DEGRADATION)
  ngx_uint_t  ngx_http_degraded(ngx_http_request_t *);
  #endif
--- 162,167 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http_request.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http_request.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/http/ngx_http_request.c	2024-08-14 12:16:22.223480211 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/http/ngx_http_request.c	2024-08-14 12:15:31.875331027 +0800
***************
*** 201,212 ****
      { ngx_null_string, 0, NULL }
  };
  
- void
- ngx_http_eyes_test_args
- (int arg)
- {
-     int j;*(volatile int *)&j = 1; // 这行保证不会被优化掉
- }
  
  void
  ngx_http_init_connection(ngx_connection_t *c)
--- 202,207 ----
***************
*** 225,238 ****
      ngx_http_in6_addr_t       *addr6;
  #endif
  
-     ngx_log_debug(NGX_LOG_ERR, c->log, 0, "[wg]: init connection %p fd %d",c,c->fd);
-     ngx_http_eyes_test_args(22345);
      hc = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t));
      if (hc == NULL) {
          ngx_http_close_connection(c);
          return;
      }
!     // wg-chain http-listen 2+3+1: 设置 conn的data为新创的ngx_http_connection in ngx_http_init_connection 
      c->data = hc;
  
      /* find the server configuration for the address:port */
--- 219,230 ----
      ngx_http_in6_addr_t       *addr6;
  #endif
  
      hc = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t));
      if (hc == NULL) {
          ngx_http_close_connection(c);
          return;
      }
! 
      c->data = hc;
  
      /* find the server configuration for the address:port */
***************
*** 330,337 ****
      c->log_error = NGX_ERROR_INFO;
  
      rev = c->read;
-     // event wg: 设置event handle,accept的fd可以read了代表用户有数据了
-     // wg-chain http-listen 2+3+2: 设置conn的read时间的hendle为ngx_http_wait_request_handler，这就是http处理的开始
      rev->handler = ngx_http_wait_request_handler;
      c->write->handler = ngx_http_empty_handler;
  
--- 322,327 ----
***************
*** 438,444 ****
          b->last = b->start;
          b->end = b->last + size;
      }
!     // wg: ngx_recv 从client读取数据 即尝试读取header_size的数据 
      n = c->recv(c, b->last, size);
  
      if (n == NGX_AGAIN) {
--- 428,434 ----
          b->last = b->start;
          b->end = b->last + size;
      }
! 
      n = c->recv(c, b->last, size);
  
      if (n == NGX_AGAIN) {
***************
*** 502,508 ****
      c->log->action = "reading client request line";
  
      ngx_reusable_connection(c, 0);
!     // wg: 创建request r.header_in = c.buffer
      c->data = ngx_http_create_request(c);
      if (c->data == NULL) {
          ngx_http_close_connection(c);
--- 492,498 ----
      c->log->action = "reading client request line";
  
      ngx_reusable_connection(c, 0);
! 
      c->data = ngx_http_create_request(c);
      if (c->data == NULL) {
          ngx_http_close_connection(c);
***************
*** 582,588 ****
      r->loc_conf = hc->conf_ctx->loc_conf;
  
      r->read_event_handler = ngx_http_block_reading;
!     // wg: request_上的 header_in 指向 connection上的 buffer
      r->header_in = hc->busy ? hc->busy->buf : c->buffer;
  
      if (ngx_list_init(&r->headers_out.headers, r->pool, 20,
--- 572,578 ----
      r->loc_conf = hc->conf_ctx->loc_conf;
  
      r->read_event_handler = ngx_http_block_reading;
! 
      r->header_in = hc->busy ? hc->busy->buf : c->buffer;
  
      if (ngx_list_init(&r->headers_out.headers, r->pool, 20,
***************
*** 626,632 ****
      r->count = 1;
  
      tp = ngx_timeofday();
-     // wg: 初始化request上的数据
      r->start_sec = tp->sec;
      r->start_msec = tp->msec;
  
--- 616,621 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/os/unix/ngx_process.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/os/unix/ngx_process.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/os/unix/ngx_process.c	2024-08-14 12:16:22.223480211 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/os/unix/ngx_process.c	2024-08-14 12:15:31.885342910 +0800
***************
*** 35,41 ****
  ngx_int_t        ngx_last_process;
  ngx_process_t    ngx_processes[NGX_MAX_PROCESSES];
  
! // signal wg: 所有的信号处理callback
  ngx_signal_t  signals[] = {
      { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),
        "SIG" ngx_value(NGX_RECONFIGURE_SIGNAL),
--- 35,41 ----
  ngx_int_t        ngx_last_process;
  ngx_process_t    ngx_processes[NGX_MAX_PROCESSES];
  
! 
  ngx_signal_t  signals[] = {
      { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),
        "SIG" ngx_value(NGX_RECONFIGURE_SIGNAL),
***************
*** 182,188 ****
  
      ngx_process_slot = s;
  
!     // wg: fork 出 worker
      pid = fork();
  
      switch (pid) {
--- 182,188 ----
  
      ngx_process_slot = s;
  
! 
      pid = fork();
  
      switch (pid) {
***************
*** 196,202 ****
      case 0:
          ngx_parent = ngx_pid;
          ngx_pid = ngx_getpid();
-         // wg: 实际上就是 ngx_worker_process_cycle
          proc(cycle, data);
          break;
  
--- 196,201 ----
***************
*** 315,321 ****
      return NGX_OK;
  }
  
! // signal wg: ngx_signal_handler 在这里
  static void
  ngx_signal_handler(int signo, siginfo_t *siginfo, void *ucontext)
  {
--- 314,320 ----
      return NGX_OK;
  }
  
! 
  static void
  ngx_signal_handler(int signo, siginfo_t *siginfo, void *ucontext)
  {
***************
*** 368,374 ****
                  action = ", exiting";
  
              } else {
-                 // signal wg: 这里读到了信号,设置了原子变量
                  ngx_reconfigure = 1;
                  action = ", reconfiguring";
              }
--- 367,372 ----
diff -crB ./openresty-wg/bundle/nginx-1.19.9/src/os/unix/ngx_process_cycle.c ./openresty-wg-bk/bundle/nginx-1.19.9/src/os/unix/ngx_process_cycle.c
*** ./openresty-wg/bundle/nginx-1.19.9/src/os/unix/ngx_process_cycle.c	2024-08-14 12:16:22.223480211 +0800
--- ./openresty-wg-bk/bundle/nginx-1.19.9/src/os/unix/ngx_process_cycle.c	2024-08-14 12:15:31.885342910 +0800
***************
*** 141,147 ****
      delay = 0;
      sigio = 0;
      live = 1;
!     // wg: the inifinity loop
      for ( ;; ) {
          if (delay) {
              if (ngx_sigalrm) {
--- 141,147 ----
      delay = 0;
      sigio = 0;
      live = 1;
! 
      for ( ;; ) {
          if (delay) {
              if (ngx_sigalrm) {
***************
*** 213,219 ****
  
              continue;
          }
!         // reload signal wg: a 1. master 收到reconfigure
          if (ngx_reconfigure) {
              ngx_reconfigure = 0;
  
--- 213,219 ----
  
              continue;
          }
! 
          if (ngx_reconfigure) {
              ngx_reconfigure = 0;
  
***************
*** 228,241 ****
              }
  
              ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");
!             // reload wg: b 2. 初始化新的cyclye
              cycle = ngx_init_cycle(cycle);
              if (cycle == NULL) {
                  cycle = (ngx_cycle_t *) ngx_cycle;
                  continue;
              }
  
-             // reload wg: c 3. 启动新的work_process
              ngx_cycle = cycle;
              ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                     ngx_core_module);
--- 228,240 ----
              }
  
              ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");
! 
              cycle = ngx_init_cycle(cycle);
              if (cycle == NULL) {
                  cycle = (ngx_cycle_t *) ngx_cycle;
                  continue;
              }
  
              ngx_cycle = cycle;
              ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                     ngx_core_module);
***************
*** 248,254 ****
              ngx_msleep(100);
  
              live = 1;
-             // reload wg: d 4. 关闭旧的worker process 
              ngx_signal_worker_processes(cycle,
                                          ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
          }
--- 247,252 ----
***************
*** 552,558 ****
          }
  
          if (ch.command) {
-             // reload wg: e 5. write quit cmd th process channel
              if (ngx_write_channel(ngx_processes[i].channel[0],
                                    &ch, sizeof(ngx_channel_t), cycle->log)
                  == NGX_OK)
--- 550,555 ----
***************
*** 758,764 ****
      exit(0);
  }
  
! // wg: worker process的入口
  static void
  ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)
  {
--- 755,761 ----
      exit(0);
  }
  
! 
  static void
  ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)
  {
***************
*** 772,796 ****
      ngx_setproctitle("worker process");
  
      for ( ;; ) {
!         // reload wg: i10. worker 知道自己在退出中
          if (ngx_exiting) {
-             // reload wg: j11. worker 发现自己没有任何的事件了
              if (ngx_event_no_timers_left() == NGX_OK) {
                  ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");
-                 // reload wg: 12. 这个函数中调用了exit(0)
                  ngx_worker_process_exit(cycle);
              }
          }
  
          ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, "worker cycle");
!         // wg: 这里就是真正开始出来所有事件的地方
          ngx_process_events_and_timers(cycle);
  
          if (ngx_terminate) {
              ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");
              ngx_worker_process_exit(cycle);
          }
!         // reload wg: g8. 发现了ngx_quit worker 认识到自己应该退了
          if (ngx_quit) {
              ngx_quit = 0;
              ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
--- 769,791 ----
      ngx_setproctitle("worker process");
  
      for ( ;; ) {
! 
          if (ngx_exiting) {
              if (ngx_event_no_timers_left() == NGX_OK) {
                  ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");
                  ngx_worker_process_exit(cycle);
              }
          }
  
          ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, "worker cycle");
! 
          ngx_process_events_and_timers(cycle);
  
          if (ngx_terminate) {
              ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");
              ngx_worker_process_exit(cycle);
          }
! 
          if (ngx_quit) {
              ngx_quit = 0;
              ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
***************
*** 798,804 ****
              ngx_setproctitle("worker process is shutting down");
  
              if (!ngx_exiting) {
-                 // reload wg: h9. worker 设置自己为退出中,关闭所有的连接,设置shutdown timer
                  ngx_exiting = 1;
                  ngx_set_shutdown_timer(cycle);
                  ngx_close_listening_sockets(cycle);
--- 793,798 ----
***************
*** 969,975 ****
  
      for (i = 0; cycle->modules[i]; i++) {
          if (cycle->modules[i]->init_process) {
-             // wg: call module's init_process
              if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {
                  /* fatal */
                  exit(2);
--- 963,968 ----
***************
*** 1128,1134 ****
          switch (ch.command) {
  
          case NGX_CMD_QUIT:
-             // reload wg: f 6. worker process receives quit command 设置ngx_quit
              ngx_quit = 1;
              break;
  
--- 1121,1126 ----
